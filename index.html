<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Borges Sphere</title>

<style>
body { margin:0; overflow:hidden; background:black; }

#overlay {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: white;
    font-family: Arial;
    font-size: 22px;
    width: 60%;
    text-align: center;
    line-height: 1.6;
    display: none;
    cursor: pointer;
}
</style>
</head>
<body>

<div id="overlay"></div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
camera.position.z = 16;

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);


const sphere = new THREE.Mesh(
    new THREE.SphereGeometry(6, 16, 16),
    new THREE.MeshBasicMaterial({
        color: 0xffffff,
        wireframe: true,
        transparent: true,
        opacity: 0.04
    })
);
scene.add(sphere);


const textData = [
{
    title: "All things happenâ€¦ precisely now",
    paragraph: "Time forks perpetually toward innumerable futures. In one of them I am your enemy; in another, your friend."
},
{
    title: "A labyrinth of time",
    paragraph: "He believed in an infinite series of times, in a growing, dizzying web of diverging, converging, and parallel times."
},
{
    title: "I imagined it infinite",
    paragraph: "The book had no beginning nor end. Each page flowed into another, as if space itself refused containment."
},
{
    title: "He wanted to dream a man",
    paragraph: "With meticulous love he dreamed him, atom by atom, eyelash by eyelash, until the dream became flesh."
}
];

function createTextSprite(message) {

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    canvas.width = 1024;
    canvas.height = 512;

    ctx.fillStyle = "white";
    ctx.font = "64px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(message, 512, 256);

    const texture = new THREE.CanvasTexture(canvas);

    const material = new THREE.SpriteMaterial({ map:texture, transparent:true });

    const sprite = new THREE.Sprite(material);
    sprite.scale.set(4.8, 2.4, 1);

    return sprite;
}

function distribute(object, i, total, radius) {
    const phi = Math.acos(-1 + (2 * i) / total);
    const theta = Math.sqrt(total * Math.PI) * phi;

    object.position.set(
        radius * Math.cos(theta) * Math.sin(phi),
        radius * Math.sin(theta) * Math.sin(phi),
        radius * Math.cos(phi)
    );
}

const sprites = [];

textData.forEach((item, i) => {

    const sprite = createTextSprite(item.title);

    distribute(sprite, i, textData.length, 6);

    sprite.userData = item;        
    sphere.add(sprite);
    sprites.push(sprite);
});


const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener('click', (event) => {

    mouse.x = (event.clientX / innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(sprites);

    if (intersects.length > 0) {

        const data = intersects[0].object.userData;

        showParagraph(data.paragraph);
    }
});

const overlay = document.getElementById("overlay");

function showParagraph(text) {

    overlay.innerText = text;
    overlay.style.display = "block";

    sphere.visible = false;  
}

overlay.addEventListener("click", () => {

    overlay.style.display = "none";
    sphere.visible = true;  
});


function animate() {
    requestAnimationFrame(animate);

    sphere.rotation.y += 0.0008;
    sphere.rotation.x += 0.0002;

    sprites.forEach(sprite => {

        sprite.quaternion.copy(camera.quaternion);

        const worldPos = sprite.getWorldPosition(new THREE.Vector3());

        if (worldPos.z < 0) {
            sprite.scale.x = -Math.abs(sprite.scale.x);
        } else {
            sprite.scale.x = Math.abs(sprite.scale.x);
        }
    });

    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
